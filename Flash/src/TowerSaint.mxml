<?xml version="1.0" encoding="utf-8"?>
<s:Application xmlns:fx="http://ns.adobe.com/mxml/2009" 
			   xmlns:s="library://ns.adobe.com/flex/spark" 
			   xmlns:mx="library://ns.adobe.com/flex/mx" 
			   minWidth="955" minHeight="600" xmlns:maps="com.google.maps.*" currentState="start">
	<fx:Script>
		<![CDATA[
			import assets.PhotoAssets;
			
			import away3dlite.cameras.*;
			import away3dlite.containers.*;
			import away3dlite.core.base.*;
			import away3dlite.core.render.*;
			import away3dlite.events.*;
			import away3dlite.lights.DirectionalLight3D;
			import away3dlite.materials.*;
			import away3dlite.primitives.*;
			
			import com.facebook.Facebook;
			import com.facebook.commands.friends.GetFriends;
			import com.facebook.commands.users.GetInfo;
			import com.facebook.data.friends.GetFriendsData;
			import com.facebook.data.users.FacebookUser;
			import com.facebook.data.users.FacebookUserCollection;
			import com.facebook.data.users.GetInfoData;
			import com.facebook.data.users.GetInfoFieldValues;
			import com.facebook.events.FacebookEvent;
			import com.facebook.net.FacebookCall;
			import com.facebook.utils.FacebookSessionUtil;
			import com.google.maps.LatLng;
			import com.google.maps.LatLngBounds;
			import com.google.maps.Map;
			import com.google.maps.MapEvent;
			import com.google.maps.MapType;
			import com.google.maps.ProjectionBase;
			import com.google.maps.overlays.GroundOverlay;
			import com.google.maps.overlays.Marker;
			import com.google.maps.overlays.MarkerOptions;
			import com.google.maps.overlays.Polygon;
			import com.google.maps.overlays.PolygonOptions;
			import com.google.maps.styles.FillStyle;
			import com.google.maps.styles.StrokeStyle;
			
			import flash.display.*;
			import flash.events.*;
			import flash.net.*;
			import flash.utils.Dictionary;
			
			import models.Bounds;
			import models.Location;
			import models.Portal;
			import models.Road;
			import models.Tower;
			import models.User;
			
			import mx.collections.ArrayCollection;
			import mx.controls.Alert;
			import mx.core.BitmapAsset;
			import mx.messaging.ChannelSet;
			import mx.messaging.channels.AMFChannel;
			import mx.rpc.AbstractOperation;
			import mx.rpc.events.FaultEvent;
			import mx.rpc.events.ResultEvent;
			import mx.rpc.remoting.RemoteObject;
			import mx.utils.ObjectProxy;
		
			
			// The facebook data
			protected var _sessionId:FacebookSessionUtil;
			protected var _facebook:Facebook;
			protected const API_KEY:String = "19c9fe5eb3168ff03f9277a78e88d095";
			protected const SECRET:String = "7daf6801550ed6972685d7f8f52b2136";
			[Bindable] protected var _user:FacebookUser = new FacebookUser();
			[Bindable] public var _friends:Array = new Array();
			
			// Away 3D data
			private var scene:Scene3D;
			private var camera:HoverCamera3D;
			private var renderer:BasicRenderer;
			private var view:View3D;
			private var light:DirectionalLight3D;
			private var listOfCannons:ArrayCollection = new ArrayCollection();
			
			// Map data
			[Bindable]
			public var listOfTowers:ArrayCollection = new ArrayCollection();
			[Bindable]
			private var listOfRoads:ArrayCollection = new ArrayCollection();
			[Bindable]
			private var listOfPortals:ArrayCollection = new ArrayCollection();
			protected const latOffset:Number = .001;
			protected const lonOffset:Number = .001;
			
			// My Cannonball
			private var sphere:Sphere;
			
			// The image data
			[Bindable] public var _photo:PhotoAssets = new PhotoAssets();
			
			// Server data
			private static const URL:String = "http://localhost:8083";
			private static const userRemoteServiceString:String = "user";
			private static const portalRemoteServiceString:String = "portal";
			private static const towerRemoteServiceString:String = "tower";
			private static const roadRemoteServiceString:String = "road";
			private var remoteObjectCollection:Dictionary = new Dictionary();
			
			// State variable
			[Bindable]private var finishedLoadingMap:Boolean = false;
			
			// Map handlers. The map handler gets called after you are logged
			// into facebook
			private function onMapReady(event:Event) : void {
				this.map.setCenter(new LatLng(42.366662,-71.106262), 11, MapType.NORMAL_MAP_TYPE);

				// Initialize the services needed with the server over amf
				initializeServicesToGoogleAppEngine();
				
				// Get all objects within the bounds of the server.	
				var bounds:LatLngBounds = this.map.getLatLngBounds();
				getAllObjectsWithinBounds(bounds);
				

				// Set an event listener upon the complete loading of the information
				this.map.addEventListener(MapEvent.TILES_LOADED, onTilesLoaded);
			}
			
			// Create the 
			private function createBasicScopePolygon(loc:LatLng) : void {
				var latlng:LatLng = loc
				var lat:Number = latlng.lat();
				var lon:Number = latlng.lng();
				var polygon:Polygon = new Polygon([
					new LatLng(lat - latOffset, lon - lonOffset),
					new LatLng(lat - latOffset, lon + lonOffset),
					new LatLng(lat + latOffset, lon + lonOffset),
					new LatLng(lat + latOffset, lon - lonOffset),
					new LatLng(lat - lonOffset, lon - lonOffset)
				], 
					new  PolygonOptions({ 
						strokeStyle: new StrokeStyle({
							color: 0x0000ff,
							thickness: 10,
							alpha: 0.7}), 
						fillStyle: new FillStyle({
							color: 0x0000ff,
							alpha: 0.7})
					}));
				map.addOverlay(polygon);
			}
			
			private function onTilesLoaded(event:MapEvent) : void {
				finishedLoadingMap = true;
			}
			
			private function drawObjectOverlays(listOfObjects:ArrayCollection) : void {
				for(var object:Object in listOfObjects){
					// Parse dependent on the object
					if(object is Tower){
						drawTower(object as Tower);
					}else if(object is Portal){
						drawPortal(object as Portal);
					}else if(object is Road){
						drawRoad(object as Road);	
					}
				}
			}
			
			private function drawPortal(portal:Portal) : void {
				// Extract the position associated with remoteObject(Tower)			
				var firstPosition:LatLng = new LatLng(portal.endLocationLatitude, portal.endLocationLongitude);
				var secondPosition:LatLng = new LatLng(portal.startLocationLatitude, portal.startLocationLongitude);
				
				// Create both portals
				_drawPortal(firstPosition);
				_drawPortal(secondPosition);
			}
			
			private function _drawPortal(pos:LatLng) : void {
				// The portal icon
				var portalIcon:BitmapAsset = new _photo.ThePortal() as BitmapAsset;
				
				// Create test overlays
				var markerOptions : MarkerOptions = new MarkerOptions();
				markerOptions.icon = portalIcon;
				markerOptions.iconAlignment = MarkerOptions.ALIGN_HORIZONTAL_CENTER | MarkerOptions.ALIGN_BOTTOM;
				markerOptions.hasShadow = false;
				markerOptions.radius = 5;
				
				// Create the marker
				var marker: Marker = new Marker(pos, markerOptions);				
				this.map.addOverlay(marker);
				
			}
			
			private function drawRoad(road:Road) : void {
				// Add a ground overlay
				var roadIcon:BitmapAsset = getRoadFromNeighbors(road);
			
				// Extract the position associated with remoteObject(Tower)			
				var gposition:LatLng = new LatLng(road.latitude, road.longitude);
				
				// Create test overlays
				var markerOptions : MarkerOptions = new MarkerOptions();
				markerOptions.icon = roadIcon;
				markerOptions.iconAlignment = MarkerOptions.ALIGN_HORIZONTAL_CENTER | MarkerOptions.ALIGN_BOTTOM;
				markerOptions.hasShadow = false;
				markerOptions.radius = 5;
				var marker: Marker = new Marker(gposition, markerOptions);				
				
				this.map.addOverlay(marker);
			}
			
			// Helper function for finding the type of road need to drawn
			// on the map.
			private function getRoadFromNeighbors(road:Road):BitmapAsset {
				
				// TODO: This value needs to be calculated properly so that depending on the
				// neighbor list different bitmaps are used.
				var neighborType:Number = 0;
				// North - (0, 1)
				// East - (0, 2)
				// South - (0, 4)
				// West - (0, 8)
				switch(neighborType){
					//case 0:
					//	return new _photo.EastRoad() as BitmapAsset;
					case 1:
						return new _photo.NorthRoad() as BitmapAsset;
					case 2:
						return new _photo.EastRoad() as BitmapAsset;
					case 3:
						return new _photo.NorthEastRoad() as BitmapAsset;
					case 4:
						return new _photo.SouthRoad() as BitmapAsset;
					case 5:
						return new _photo.NorthSouthRoad() as BitmapAsset;
					case 6:
						return new _photo.SouthEastRoad() as BitmapAsset;
					case 7:
						return new _photo.NorthSouthEastRoad() as BitmapAsset;
					case 8:
						return new _photo.WestRoad() as BitmapAsset;
					case 9:
						return new _photo.NorthWestRoad() as BitmapAsset;
					case 10:
						return new _photo.EastWestRoad() as BitmapAsset;
					case 11:
						return new _photo.NorthEastWestRoad() as BitmapAsset;
					case 12:
						return new _photo.SouthWestRoad() as BitmapAsset;
					case 13:
						return new _photo.NorthSouthWestRoad() as BitmapAsset;
					case 14:
						return new _photo.SouthEastWestRoad() as BitmapAsset;
					case 15:
						return new _photo.NorthSouthEastWestRoad() as BitmapAsset;
					default:
						return new _photo.EastRoad() as BitmapAsset;
				}
			}
			
			private function drawTower(tower:Tower) : void {
				// Add a test ground overlay
				var towerIcon:BitmapAsset;
				switch(tower.Level){
					// Tower image
					case 0:
						towerIcon =  new _photo.TowerLevel0() as BitmapAsset;
						break;
					// Fort image
					case 1:
						towerIcon = new _photo.TowerLevel1() as BitmapAsset;
						break;
					// Castle image
					case 2:
						towerIcon = new _photo.TowerLevel2() as BitmapAsset;
						break;
					// TowerSaint image
					case 3:
						towerIcon = new _photo.TowerSaint() as BitmapAsset;
						break;
					default:
						towerIcon =  new _photo.TowerLevel0() as BitmapAsset;
						break;
				}
				
				// Extract the position associated with remoteObject(Tower)			
				var gposition:LatLng = new LatLng(tower.latitude, tower.longitude);

				
				// Create test overlays
				var markerOptions : MarkerOptions = new MarkerOptions();
				markerOptions.icon = towerIcon;
				markerOptions.iconAlignment = MarkerOptions.ALIGN_HORIZONTAL_CENTER | MarkerOptions.ALIGN_BOTTOM;
				markerOptions.hasShadow = true;
				markerOptions.radius = 5;
				var marker: Marker = new Marker(gposition, markerOptions);				
				
				this.map.addOverlay(marker);
			}
			
			// The button handlers
			protected function loginBtnClickHandler(event:MouseEvent) : void {
				_sessionId = new FacebookSessionUtil(API_KEY, SECRET, loaderInfo);
				_facebook = _sessionId.facebook;
				_sessionId.addEventListener(FacebookEvent.CONNECT, onFacebookConnect);
				_sessionId.addEventListener(FacebookEvent.WAITING_FOR_LOGIN, onWaitLogin);
				_sessionId.addEventListener(FacebookEvent.ERROR, onError);
				_sessionId.login();
			}
			
			protected function onError(event:FacebookEvent) : void {
				var alert:Alert = Alert.show(event.error.errorMsg, "Error!!");
			}
			
			protected function logoutBtnClickHandler(event:MouseEvent) : void {
				_sessionId.logout();
				currentState = "start";
				_user = new FacebookUser();

			}
			
			// The facebook handlers
			protected function onWaitLogin(event:FacebookEvent):void {
				var alert:Alert = Alert.show("Click OK afer you log in Facebook", "Waiting for login");
				alert.addEventListener(Event.CLOSE, onClose);
			}
			

			
			protected function onClose(event:Event):void{
				_sessionId.validateLogin();	
			}
			
			protected function onFacebookConnect(event:FacebookEvent) : void {
				if(event.success){
					currentState = "inApp";
					
					// Initialize the 3D view
					init3DView();
					
					// Get the user information
					var call:FacebookCall = _facebook.post(new GetInfo([_facebook.uid], [GetInfoFieldValues.ALL_VALUES]));
					call.addEventListener(FacebookEvent.COMPLETE, onGetInfo);
					
					// Get the friend list
					var friendListCall:FacebookCall = _facebook.post(new GetFriends(null, _facebook.uid));
					friendListCall.addEventListener(FacebookEvent.COMPLETE, onGetFriendsList);
				}else{
					Alert.show("Error connecting to Facebook" + event.error.rawResult , "Error" + event.error.errorCode);
				}
				
			}
			
			protected function onGetInfo(event : FacebookEvent) : void {
				
			}
				
			protected function onGetFriendsList(event:FacebookEvent) : void {
				var _friendsUid:Array = new Array();
				var users:FacebookUserCollection = (event.data as GetFriendsData).friends;
				
				// Iterate over the users
				for(var i:int; i < users.length; i++){
					_friendsUid.push((users.getItemAt(i) as FacebookUser).uid);
				}
				
				var friendsDetailsCall:FacebookCall = _facebook.post(new GetInfo(_friendsUid, [GetInfoFieldValues.ALL_VALUES]));
				friendsDetailsCall.addEventListener(FacebookEvent.COMPLETE, onFriendsGetInfo);
			}
		
			protected function onFriendsGetInfo(event:FacebookEvent) : void {
				var users:FacebookUserCollection = (event.data as GetInfoData).userCollection;
				for(var i:int; i < users.length; i++){
					var userInfoObject:Object = users.getItemAt(i);
					_friends.push(userInfoObject.first_name as String);
				}
				// Setup up the data provider
				friendsDetailGrid.dataProvider = _friends;
			}
			
			// Away3D information
			private function init3DView() : void {
				// I am only initializing objects, since the 3D aspects of the
				// game have no user interactions
				initEngine();
				initObjects();
				initListeners();
			}
			
			private function initEngine() : void {
				// Create the scene
				scene = new Scene3D();
				
				// Create the camera
				camera = new HoverCamera3D();
				camera.focus = 50;
				camera.distance = 1000;
				camera.minTiltAngle = 0;
				camera.maxTiltAngle = 180;
				camera.panAngle =90;
				camera.tiltAngle = 180;
				camera.hover(true);
				
				// Create the renderer
				renderer = new BasicRenderer();
				
				// Create the view
				view = new View3D();
				view.scene = scene;
				view.camera = camera;
				view.renderer = renderer;
				
				// Add the children to the sprite
				mySprite.addChild(this.map);
				mySprite.addChild(view);
			}
			
			private function initObjects() : void {
				// Create a new material 
				
				var towerIcon:BitmapAsset = new _photo.cannonMaterial() as BitmapAsset;
				var towerData:BitmapData = towerIcon.bitmapData;
				var cannonMaterial:BitmapMaterial = new BitmapMaterial(towerData);
				cannonMaterial.smooth = true;
				// Create the sphere
				sphere = new Sphere();
				sphere.x = 100;
				sphere.y = 0;
				sphere.z = 100;
				sphere.radius = 150;
				sphere.segmentsH = 12;
				sphere.segmentsW = 12;
				sphere.name = "mySphere";
				sphere.material = cannonMaterial;
				scene.addChild(sphere);
			}
			
			// Setup the listeners
			private function initListeners() : void {
				// Setup some event listeners
				addEventListener(Event.ENTER_FRAME, onEnterFrame);
				focusPanel.addEventListener(Event.RESIZE, onResize);
				onResize();
			}
			
			// Resize the window
			private function onResize(event:Event=null):void {
				view.x = focusPanel.width / 2;
				view.y = focusPanel.height / 2;
			}
			
			// Enter the frame
			private function onEnterFrame(event:Event) : void {
				if(finishedLoadingMap){
					//camera.hover();
					
					// Change the z position of the sphere
					//sphere.z = (sphere.z + 10) % 100 - 100
					
					
					//view.render();
				}
			}
			
			// Server interface
			protected function initializeServicesToGoogleAppEngine() : void {
				var channel:AMFChannel = new AMFChannel("pyamf-channel", URL);
				var channels:ChannelSet = new ChannelSet();
				channels.addChannel(channel);
				
				// Create a remote object for each major class
				createRemoteObject(channels, userRemoteServiceString);
				createRemoteObject(channels, portalRemoteServiceString);
				createRemoteObject(channels, towerRemoteServiceString);
				createRemoteObject(channels, roadRemoteServiceString);
			}
			
			protected function createRemoteObject(channel:ChannelSet, stringOfRemoteObject:String) : void {
				// Create the remote object	
				var remoteObject:RemoteObject = new RemoteObject(stringOfRemoteObject);
				remoteObject.showBusyCursor = true;
				remoteObject.channelSet = channel;
				remoteObject.addEventListener(FaultEvent.FAULT, onRemoteServiceFault);
				remoteObject.addEventListener(SecurityErrorEvent.SECURITY_ERROR, onRemoteServiceFault);
			
				// Store a reference to the remote object
				remoteObjectCollection[stringOfRemoteObject] = remoteObject;
			}
			
			protected function onRemoteServiceFault(event:FaultEvent) : void {
				var errorMsg:String = "Service error:\n" + event.fault.faultCode;
				Alert.show(event.fault.faultDetail, errorMsg);
			}
			
			protected function onRemoteServiceSecurityError(event:SecurityErrorEvent) : void {
				var errorMsg:String = "Service security error";
				Alert.show(event.text, errorMsg);
			}
			
			// Get all objects from the server within the bounds of the viewsable map
			// bounds:google.maps.LatLngBounds of the current screen.
			protected function getAllObjectsWithinBounds(bounds:LatLngBounds) : void {
				// Get each one of the corresponding objects
				getObjectWithinBound(portalRemoteServiceString, googleToAMFBounds(bounds));
				getObjectWithinBound(towerRemoteServiceString, googleToAMFBounds(bounds));
				getObjectWithinBound(roadRemoteServiceString, googleToAMFBounds(bounds));
			}
			
			// Change the google object into a bounds object
			protected function googleToAMFBounds(bounds:LatLngBounds):Bounds {
				var bond:Bounds = new Bounds();
				bond.northeastLocation = googleToAMFLocation(bounds.getNorthEast());				
				bond.southwestLocation = googleToAMFLocation(bounds.getSouthWest());
				return bond;
			}
			
			// Change the google lat lng into a location object
			protected function googleToAMFLocation(loc:LatLng):Location {
				var myLoc:Location = new Location();
				
				// Set the latitude/longitude
				myLoc.latitude = loc.lat();
				myLoc.longitude = loc.lng();
				myLoc.latIndex = int(myLoc.latitude / latOffset);
				myLoc.lonIndex = int(myLoc.longitude / lonOffset);
				
				// Set the latitude/longitude index
				
				return myLoc;
			}
			
			
			protected function getObjectWithinBound(serviceString:String, bounds:Bounds) : void {
				// Get the service
				var _service:RemoteObject = remoteObjectCollection[serviceString] as RemoteObject;
				
				// Setup the abstract operation
				var operation:AbstractOperation = _service.getOperation("getObjectInBounds");
				if(serviceString == "portal"){
					operation.addEventListener(ResultEvent.RESULT, onGetAllPortalObjectsFromServer);
				}else if(serviceString == "tower"){
					operation.addEventListener(ResultEvent.RESULT, onGetAllTowerObjectsFromServer);
				}else if(serviceString == "road"){
					operation.addEventListener(ResultEvent.RESULT, onGetAllRoadObjectsFromServer);
				}
				operation.send(bounds);
			}
			
			protected function onGetAllPortalObjectsFromServer(event:ResultEvent) : void {
				listOfPortals = event.result as ArrayCollection;
				for(var i:Number = 0; i < listOfPortals.length; i++){
					var p:Portal = listOfPortals.getItemAt(i) as Portal;
					drawPortal(p);
				}
			}
			
			protected function onGetAllTowerObjectsFromServer(event:ResultEvent) : void {
				listOfTowers = event.result as ArrayCollection;

				for(var i:Number = 0; i < listOfTowers.length; i++){
					var t:Tower = listOfTowers.getItemAt(i) as Tower;
					drawTower(t);

				}
			}
			
			protected function onGetAllRoadObjectsFromServer(event:ResultEvent) : void {
				listOfRoads = event.result as ArrayCollection;
				for(var i:Number = 0; i < listOfRoads.length; i++){
					var r:Road = listOfRoads.getItemAt(i) as Road;
					drawRoad(r);
				}
			}
			
			protected function onGetAllObjectsFromServer(event:ResultEvent) : void {
				// Get the array collection
				var collection:ArrayCollection = event.result as ArrayCollection;
				// Get the first item
				var obj:Object = collection.getItemAt(0);

				// Each object has its own services. This should function properly
				if(obj is Portal){
					listOfPortals = collection;
					drawObjectOverlays(listOfPortals);
				}else if(obj is Road){
					listOfRoads = collection;
					drawObjectOverlays(listOfRoads);
				}else if(obj is Tower){
					listOfTowers = collection;
					drawObjectOverlays(listOfTowers);
				}
			}
			
			protected function onSendButtonClicked(event:MouseEvent) : void {
				// The network connection
				var netConnection:NetConnection = new NetConnection();
				netConnection.connect("http://localhost:8083/");
				
				// The responseder
				var responder:Responder = new Responder(onSendButtonComplete, onSendButtonFail);
				netConnection.call("myservice.echo", responder, sendServer.text);
			}
			
			protected function onSendButtonComplete(results : String): void {
				reponseServer.text = results;	
			}
			
			protected function onSendButtonFail(results : Object) : void {
				for each(var thisResult in results){
					reponseServer.text += thisResult;
				}
			}
		]]>
	</fx:Script>
	<s:states>
		<s:State name="inApp"/>
		<s:State name="start"/>
	</s:states>
	<fx:Declarations>
		<!-- Place non-visual elements (e.g., services, value objects) here -->
	</fx:Declarations>
	<s:Panel x="231" y="76" width="100%" height="100%" includeIn="inApp" id="visPanel">
		<s:SpriteVisualElement id="mySprite"/>
		<maps:Map x="0" y="0" id="map" width="100%" height="100%" mapevent_mapready="onMapReady(event)" key="ABQIAAAA5PSKhvT9XxMwIJsiXZLnshT2yXp_ZAY8_ufC3CFXhHIE1NvwkxSamfgDn9m0J6XvaIp6AGWbB8RA4A"/>
	</s:Panel>
	<s:Button includeIn="start" x="67" y="53" label="Login" id="loginButton" click ="loginBtnClickHandler(event)"/>
	<s:Label includeIn="inApp" x="44" y="30" text="Welcome {_user.name}"/>
	<mx:DataGrid includeIn="inApp" x="194" y="10" height="58" width="270" id="friendsDetailGrid">
		<mx:columns>
			<mx:DataGridColumn headerText="First Name" dataField="col1"/>
		</mx:columns>
	</mx:DataGrid>
	<s:Button includeIn="inApp" x="488" y="30" label="Logout" click="logoutBtnClickHandler(event)"/>
	<s:Panel includeIn="inApp" x="5" y="76" width="218" height="514" id="focusPanel">
		<mx:Image x="10" y="10" width="114" height="114" id="focusImage"/>
		<s:Button x="136" y="450" label="Updgrade" id="updgradeButton"/>
		<s:RichEditableText x="10" y="132" width="196" height="310" id="bodyText"/>
		<s:RichEditableText x="132" y="10" height="114" id="titleText" width="74"/>
	</s:Panel>
	<s:TextInput includeIn="inApp" x="688" y="10" id="sendServer"/>
	<s:TextInput includeIn="inApp" x="688" y="40" id="reponseServer"/>
	<s:Label includeIn="inApp" x="599" y="18" text="Send"/>
	<s:Label includeIn="inApp" x="599" y="48" text="Response"/>
	<s:Button includeIn="inApp" x="856" y="11" label="Send" id="sendButton" click="onSendButtonClicked(event)"/>
</s:Application>
